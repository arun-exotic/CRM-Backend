import {
    Injectable,
    ConflictException,
    UnauthorizedException,
  } from '@nestjs/common';
  import { PrismaService } from '../prisma/prisma.service';
  import { JwtService } from '@nestjs/jwt';
  import * as bcrypt from 'bcrypt';
  import { RegisterDto } from './dto/register.dto';
  import { LoginDto } from './dto/login.dto';
  import { Role as PrismaRole } from '@prisma/client';
  
  @Injectable()
  export class AuthService {
    constructor(
      private prisma: PrismaService,
      private jwtService: JwtService,
    ) {}
  
    async register(dto: RegisterDto) {
      const existing = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });
      if (existing) {
        throw new ConflictException('Email already registered');
      }
  
      const hash = await bcrypt.hash(dto.password, 10);
  
      const user = await this.prisma.user.create({
        data: {
          name: dto.name,
          email: dto.email,
          password: hash,
          role: PrismaRole.USER,
        },
      });
  
      return { id: user.id, email: user.email, name: user.name };
    }
  
    async login(dto: LoginDto) {
      const user = await this.prisma.user.findUnique({
        where: { email: dto.email },
      });
      if (!user) throw new UnauthorizedException('Invalid credentials');
  
      const ok = await bcrypt.compare(dto.password, user.password);
      if (!ok) throw new UnauthorizedException('Invalid credentials');
  
      const payload = {
        sub: user.id,
        email: user.email,
        role: user.role,
      };
  
      const token = await this.jwtService.signAsync(payload);
  
      return {
        access_token: token,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        },
      };
    }
  }
  